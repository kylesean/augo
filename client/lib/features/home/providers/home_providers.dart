import 'dart:async';
import 'package:logging/logging.dart';
import 'package:augo/features/auth/providers/auth_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:intl/intl.dart';
import 'package:augo/features/home/models/daily_expense_summary_model.dart';
import 'package:augo/features/home/models/total_expense_model.dart';
import 'package:augo/features/home/models/transaction_model.dart';
import 'package:augo/features/home/services/home_service.dart';
import 'package:augo/features/profile/providers/financial_settings_provider.dart';
import 'package:augo/features/profile/models/financial_settings.dart';
import 'package:augo/i18n/strings.g.dart';

part 'home_providers.g.dart';

enum TransactionFeedType { all, expense, income }

@riverpod
class CurrentTransactionFeedType extends _$CurrentTransactionFeedType {
  @override
  TransactionFeedType build() => TransactionFeedType.all;

  void set(TransactionFeedType value) => state = value;
}

@riverpod
class CurrentDisplayMonth extends _$CurrentDisplayMonth {
  @override
  DateTime build() {
    final now = DateTime.now();
    return DateTime(now.year, now.month);
  }

  void update(DateTime Function(DateTime state) cb) => state = cb(state);
}

@riverpod
class SelectedDate extends _$SelectedDate {
  @override
  DateTime? build() => null;

  void set(DateTime? date) => state = date;
}

@riverpod
Future<TotalExpenseData> totalExpense(Ref ref) async {
  final token = ref.watch(authTokenProvider);
  if (token == null) {
    throw Exception(t.home.userNotLoggedIn);
  }
  // Subscribe to currency changes (NotifierProvider generated by @riverpod doesn't support .select() directly)
  ref.watch(financialSettingsProvider).primaryCurrency;

  final homeService = ref.read(homeServiceProvider);
  return homeService.getTotalExpense();
}

@riverpod
Future<CalendarMonthData> calendarMonthData(Ref ref, DateTime monthYear) async {
  final token = ref.watch(authTokenProvider);
  if (token == null) {
    throw Exception(t.home.userNotLoggedIn);
  }
  ref.watch(financialSettingsProvider).primaryCurrency;

  final homeService = ref.read(homeServiceProvider);
  return homeService.getCalendarMonthDetails(monthYear.year, monthYear.month);
}

@riverpod
Future<List<TransactionModel>> transactionsForSelectedDate(
  Ref ref,
  DateTime date,
) async {
  ref.watch(financialSettingsProvider).primaryCurrency;

  final homeService = ref.read(homeServiceProvider);
  return homeService.getTransactionsForDate(date);
}

class TransactionFeedState {
  final List<TransactionModel> transactions;
  final bool isLoadingMore;
  final bool hasReachedMax;
  final int currentPage;
  final String? errorMessage;

  TransactionFeedState({
    this.transactions = const [],
    this.isLoadingMore = false,
    this.hasReachedMax = false,
    this.currentPage = 1,
    this.errorMessage,
  });

  TransactionFeedState copyWith({
    List<TransactionModel>? transactions,
    bool? isLoadingMore,
    bool? hasReachedMax,
    int? currentPage,
    String? errorMessage,
    bool clearErrorMessage = false,
  }) {
    return TransactionFeedState(
      transactions: transactions ?? this.transactions,
      isLoadingMore: isLoadingMore ?? this.isLoadingMore,
      hasReachedMax: hasReachedMax ?? this.hasReachedMax,
      currentPage: currentPage ?? this.currentPage,
      errorMessage: clearErrorMessage
          ? null
          : errorMessage ?? this.errorMessage,
    );
  }
}

@riverpod
class TransactionFeed extends _$TransactionFeed {
  final _logger = Logger('TransactionFeed');
  static const int _pageSize = 20;

  @override
  TransactionFeedState build() {
    // Listen to feed type changes
    ref.listen<TransactionFeedType>(currentTransactionFeedTypeProvider, (
      previous,
      next,
    ) {
      if (previous != next) {
        ref.read(selectedDateProvider.notifier).set(null);
        refreshFeed();
      }
    });

    // Listen to selected date changes
    ref.listen<DateTime?>(selectedDateProvider, (previous, next) {
      if (previous != next) {
        refreshFeed();
      }
    });

    // Listen to currency/financial setting changes
    // Automatically trigger feed refresh when primaryCurrency changes
    ref.listen<FinancialSettingsState>(financialSettingsProvider, (
      previous,
      next,
    ) {
      if (previous != null &&
          previous.primaryCurrency != next.primaryCurrency) {
        _logger.info(
          "Currency changed from ${previous.primaryCurrency} to ${next.primaryCurrency}, refreshing feed",
        );
        refreshFeed();
      }
    });

    // Watch auth token to trigger initial load
    final token = ref.watch(authTokenProvider);
    if (token != null) {
      Future.microtask(() => refreshFeed());
    }

    return TransactionFeedState();
  }

  String? _mapFeedTypeToApiString(TransactionFeedType feedType) {
    switch (feedType) {
      case TransactionFeedType.expense:
        return 'expense';
      case TransactionFeedType.income:
        return 'income';
      case TransactionFeedType.all:
        return null;
    }
  }

  Future<void> _fetchInitialTransactions({bool isRefresh = false}) async {
    // Check if provider is still valid
    if (!ref.mounted) {
      _logger.warning("Provider disposed before fetch, aborting");
      return;
    }

    final currentFeedType = ref.read(currentTransactionFeedTypeProvider);
    final selectedDate = ref.read(selectedDateProvider);
    final apiTypeString = _mapFeedTypeToApiString(currentFeedType);
    final apiDateString = selectedDate != null
        ? DateFormat('yyyy-MM-dd').format(selectedDate)
        : null;

    state = state.copyWith(
      isLoadingMore: true,
      currentPage: 1,
      transactions: isRefresh ? [] : state.transactions,
      hasReachedMax: false,
      clearErrorMessage: true,
    );

    try {
      final homeService = ref.read(homeServiceProvider);
      final newTransactions = await homeService.getTransactionFeed(
        page: 1,
        type: apiTypeString,
        date: apiDateString,
      );

      // Riverpod 3.0: use ref.mounted to check if provider is still valid
      if (!ref.mounted) {
        _logger.info("Provider disposed during fetch, discarding result");
        return;
      }

      state = state.copyWith(
        transactions: newTransactions,
        isLoadingMore: false,
        hasReachedMax: newTransactions.length < _pageSize,
        currentPage: 1,
      );
    } catch (e) {
      _logger.severe("Error fetching initial transaction feed", e);

      // Check if provider is still valid
      if (!ref.mounted) return;

      state = state.copyWith(
        isLoadingMore: false,
        hasReachedMax: true,
        errorMessage: e.toString(),
      );
    }
  }

  Future<void> fetchMoreTransactions() async {
    if (state.isLoadingMore || state.hasReachedMax) return;

    // Riverpod 3.0: use ref.mounted to check if provider is still valid
    if (!ref.mounted) return;

    final currentFeedType = ref.read(currentTransactionFeedTypeProvider);
    final selectedDate = ref.read(selectedDateProvider);
    final apiTypeString = _mapFeedTypeToApiString(currentFeedType);
    final apiDateString = selectedDate != null
        ? DateFormat('yyyy-MM-dd').format(selectedDate)
        : null;

    state = state.copyWith(isLoadingMore: true, clearErrorMessage: true);
    final nextPage = state.currentPage + 1;
    try {
      final homeService = ref.read(homeServiceProvider);
      final newTransactions = await homeService.getTransactionFeed(
        page: nextPage,
        type: apiTypeString,
        date: apiDateString,
      );

      // Check again after async operation
      if (!ref.mounted) return;

      if (newTransactions.isEmpty) {
        state = state.copyWith(hasReachedMax: true, isLoadingMore: false);
      } else {
        state = state.copyWith(
          transactions: [...state.transactions, ...newTransactions],
          isLoadingMore: false,
          currentPage: nextPage,
          hasReachedMax: newTransactions.length < _pageSize,
        );
      }
    } catch (e) {
      _logger.severe("Error fetching more transactions", e);

      if (!ref.mounted) return;

      state = state.copyWith(
        isLoadingMore: false,
        hasReachedMax: true,
        errorMessage: e.toString(),
      );
    }
  }

  Future<void> refreshFeed() async {
    await _fetchInitialTransactions(isRefresh: true);
  }

  Future<bool> deleteTransaction(String transactionId) async {
    final transactionIndex = state.transactions.indexWhere(
      (t) => t.id == transactionId,
    );
    if (transactionIndex == -1) return false;

    final deletedTransaction = state.transactions[transactionIndex];
    final updatedList = List<TransactionModel>.from(state.transactions);
    updatedList.removeAt(transactionIndex);
    state = state.copyWith(transactions: updatedList);

    try {
      final homeService = ref.read(homeServiceProvider);
      await homeService.deleteTransaction(transactionId);
      return true;
    } catch (e) {
      final rollbackList = List<TransactionModel>.from(state.transactions);
      rollbackList.insert(transactionIndex, deletedTransaction);
      state = state.copyWith(transactions: rollbackList);
      return false;
    }
  }
}
